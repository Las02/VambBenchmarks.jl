var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [VambBenchmarks]\nOrder   = [:type, :function]","category":"page"},{"location":"reference/#VambBenchmarks.Bin","page":"Reference","title":"VambBenchmarks.Bin","text":"Bin(name::AbstractString, sequences, targets)\n\nBins each represent a bin created by the binner. Conceptually, they are simply a set of Sequence with a name attached. Practically, every Bin is benchmarked against all Genomes and Clades of a given Reference, so each Bin stores data about its intersection with every genome/clade, e.g. its purity and recall.\n\nLike Sources, Bins also have an assembly size for a given source. This is the number of base pairs in the source covered by any sequence in the Bin, which is always a subset of the Source's assembly size.\n\nBenchmark statistics for a Bin/Genome can be done with either assemblies or _genomes as the ground truth.\n\nTrue positives (TP) are defined as the sum of assembly sizes over all sources in the genome\nFalse positives (FP) are the sum of length of sequences in the bin not mapping to the Genome\nFalse negatives (FN) is either the genome assembly size or genome size minus TP.\n\nFor Bin/Clade pairs B/C, recall is the maximal recall of B/Ch for all children Ch of C. Precision is the sum of lengths of sequences mapping to any child of the clade divided by the sum of lengths of all sequences in the bin.\n\nSee also: Binning, Genome, Clade\n\nExamples\n\njulia> bin = first(binning.bins)\nBin \"C1\"\n  Sequences: 2\n  Breadth:   65\n  Intersecting 1 genomes\n\njulia> first(bin.sequences)\nSequence(\"s1\", 25)\n\njulia> f1(first(ref.genomes), bin)\n0.625\n\n\n\n\n\n","category":"type"},{"location":"reference/#VambBenchmarks.Binning","page":"Reference","title":"VambBenchmarks.Binning","text":"Binning\n\nA Binning represents a set of Bins benchmarked against a Reference. Binnings can be created given a set of Bins and a Reference, where the bins may potentially be loaded from a .tsv file. The field binning.recoverable_genomes shows the maximal number of recoverable genomes at given recall levels given perfect binning. The fields recovered_asms and recovered_genomes are used for benchmarking, these are normally output using the print_matrix function.\n\nSee also: print_matrix, Bin, Reference\n\nExamples\n\njulia> bins = gold_standard(ref);\n\njulia> bins isa Binning\ntrue\n\njulia> VambBenchmarks.n_nc(binning)\n0\n\n\n\n\n\n","category":"type"},{"location":"reference/#VambBenchmarks.Clade","page":"Reference","title":"VambBenchmarks.Clade","text":"Clade{Genome}(name::AbstractString, child::Union{Clade{Genome}, Genome})\n\nA Clade represents any clade above Genome. Every Genome is expected to belong to the same number of clades, e.g. there may be exactly 7 levels of clades above every Genome. Clades always have at least one child (which is either a Genome or a Clade one rank lower), and a parent, unless it's the unique top clade from which all other clades and genomes descend from. The rank of a Genome is 0, clades that contain genomes have rank 1, and clades containing rank-1 clades have rank 2 etc. By default, zero-indexed ranks correspond to OTU, species, genus, family, order, class, phylum and domain.\n\nExamples\n\njulia> top_clade(ref)\nGenus \"F\", 3 genomes\n├─ Species \"D\", 2 genomes\n│  ├─ Genome(gA)\n│  └─ Genome(gB)\n└─ Species \"E\", 1 genome\n   └─ Genome(gC)\n\njulia> top_clade(ref).children\n2-element Vector{Clade{Genome}}:\n Species \"D\", 2 genomes\n Species \"E\", 1 genome\n\n\n\n\n\n","category":"type"},{"location":"reference/#VambBenchmarks.FlagSet","page":"Reference","title":"VambBenchmarks.FlagSet","text":"FlagSet <: AbstractSet{Flag}\n\nFlags are compact sets of Flag associated to a Genome. You can construct them from an iterable of Flag, e.g. a 1-element tuple. FlagSet support most set operations efficiently.\n\nExamples\n\njulia> flags = FlagSet((Flags.organism, Flags.virus));\n\njulia> Flags.virus in flags\ntrue\n\njulia> isdisjoint(flags, FlagSet((Flags.organism,)))\nfalse\n\nSee also: Flag, Genome\n\n\n\n\n\n","category":"type"},{"location":"reference/#VambBenchmarks.Flags.Flag","page":"Reference","title":"VambBenchmarks.Flags.Flag","text":"Flag\n\nA flag is a boolean associated to a Genome, stored in a Flags object. A flag may be e.g. Flag.organism, signaling that the genome is known to be an organism.\n\nSee also: FlagSet, Genome\n\n\n\n\n\n","category":"type"},{"location":"reference/#VambBenchmarks.Genome","page":"Reference","title":"VambBenchmarks.Genome","text":"Genome(name::AbstractString [flags::FlagSet])\n\nGenomes represent individual target genomes (organisms, plasmids, viruses etc), analogous to lowest-level clade that can be reconstructed. Conceptually, Genomes contain one or more Sources, and to a single parent Clade. They are identified uniquely among genomes by their name.\n\nA genome have a genome size, which is the sum of the length of all its sources. We consider this to be the true size of the biological genome (assuming its full sequence is contained in its sources), as well as an assembly size, which represent the sum of the assembly sizes of each source.\n\nSee also: Clade, Source, mrca\n\nExamples\n\njulia> gA, gB, gC = collect(ref.genomes);\n\njulia> mrca(gA, gB)\nSpecies \"D\", 2 genomes\n├─ Genome(gA)\n└─ Genome(gB)\n\n\n\n\n\n","category":"type"},{"location":"reference/#VambBenchmarks.Reference","page":"Reference","title":"VambBenchmarks.Reference","text":"Reference\n\nA Reference contains the ground truth to benchmark against. Conceptually, it consists of the following parts:\n\nA list of genomes, each with sources\nThe full taxonomic tree, as lists of clades\nA list of sequences, each with a list of (source, span) to where it maps.\n\nNormally, the types FlagSet Genome, Source, Clade and Sequence do not need to be constructed manually, but are constructed when the Reference is loaded from a JSON file.\n\nConstruct a Reference with open(i -> Reference(i), \"path/to/ref.json\").\n\nExamples\n\njulia> ngenomes(ref)\n3\n\njulia> nseqs(ref)\n11\n\njulia> first(ref.genomes) isa Genome\ntrue\n\nSee also: subset, Genome, Clade\n\n\n\n\n\n","category":"type"},{"location":"reference/#VambBenchmarks.Sequence","page":"Reference","title":"VambBenchmarks.Sequence","text":"Sequence(name::AbstractString, length::Integer)\n\nType that represents a binnable sequence. Sequences do not contain other information than their name and their length, and are identified by their name.\n\nExamples\n\njulia> Sequence(\"abc\", 5)\nSequence(\"abc\", 5)\n\njulia> Sequence(\"abc\", 5) == Sequence(\"abc\", 9)\ntrue\n\njulia> Sequence(\"abc\", 0)\nERROR: ArgumentError: Cannot instantiate an empty sequence\n\n\n\n\n\n","category":"type"},{"location":"reference/#VambBenchmarks.Source","page":"Reference","title":"VambBenchmarks.Source","text":"Source{Genome}(g::Genome, name::AbstractString, length::Integer)\n\nSources are the \"ground truth\" sequences that the binning attempts to recreate. For example, the assembled contigs of the reference genome (typically full, closed circular contigs) as found in NCBI or elsewhere are each Sources. Many Genomes only contain a single Source namely its full assembled genome. Each Source has a single parent Genome, and a unique name which identifies it.\n\nSources have zero or more mapping Sequences, that each map to the Source at a given span given by a UnitRange{Int}.\n\nSources have an assembly size, which is the number of base pairs where any sequence map to.\n\n\n\n\n\n","category":"type"},{"location":"reference/#VambBenchmarks.mrca-Tuple{Union{Clade{Genome}, Genome}, Union{Clade{Genome}, Genome}}","page":"Reference","title":"VambBenchmarks.mrca","text":"mrca(a::Node, b::Node)::Node\n\nCompute the most recent common ancestor (MRCA) of a and b.\n\n\n\n\n\n","category":"method"},{"location":"reference/#VambBenchmarks.print_matrix-Tuple{Binning}","page":"Reference","title":"VambBenchmarks.print_matrix","text":"print_matrix(::Binning; level=0, assembly=true)\n\nPrint the number of reconstructed assemblies or genomes at the given taxonomic level (rank). Level 0 corresponds to genomes, level 1 to species, etc. If assembly, print the number of reconstructed assemblies, else print the level of reconstructed genomes.\n\nSee also: Binning\n\n\n\n\n\n","category":"method"},{"location":"reference/#VambBenchmarks.subset!-Tuple{Reference}","page":"Reference","title":"VambBenchmarks.subset!","text":"subset!(ref::Reference, sequences::Function, genomes::Function)::Reference\n\nMutate ref in place, removing genomes and sequences. Keep only sequences S where sequences(S) returns true and genomes G for which genomes(G) returns true.\n\nSee also: subset, Reference\n\nExamples\n\njulia> ref\nReference\n  Genomes:    3\n  Sequences:  11\n  Ranks:      3\n  Seq length: 10\n  Assembled:  66.8 %\n\njulia> subset(ref; genomes=g -> Flags.organism in flags(g))\nReference\n  Genomes:    2\n  Sequences:  11\n  Ranks:      3\n  Seq length: 10\n  Assembled:  91.3 %\n\njulia> VambBenchmarks.subset(ref; sequences=s -> length(s) ≥ 25)\nReference\n  Genomes:    3\n  Sequences:  9\n  Ranks:      3\n  Seq length: 25\n  Assembled:  61.1 %\n\n\n\n\n\n","category":"method"},{"location":"reference/#VambBenchmarks.subset-Tuple{Reference}","page":"Reference","title":"VambBenchmarks.subset","text":"subset(ref::Reference; kwargs...)\n\nNon-mutating copying version of subset.\n\nSee also: subset!\n\n\n\n\n\n","category":"method"},{"location":"walkthrough/#Example-walkthrough","page":"Example walkthrough","title":"Example walkthrough","text":"","category":"section"},{"location":"walkthrough/","page":"Example walkthrough","title":"Example walkthrough","text":"Note: This is run with commit db18e475","category":"page"},{"location":"#VambBenchmarks","page":"Home","title":"VambBenchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VambBenchmarks.jl is a package for efficient benchmarking and interactive exploration of a set of bins against a reference.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia - preferably using juliaup: https://github.com/JuliaLang/juliaup\nLaunch Julia: julia\nPress ] to enter package mode. You can exit package mode with backspace.\nIn package mode, type add https://github.com/jakobnissen/VambBenchmarks.jl to download and install the benchmarking software","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using VambBenchmarks\nref =  open(i -> Reference(i), \"files/ref.json\")\nbins = open(i -> Binning(i, ref), \"files/clusters.tsv\")\nprint_matrix(bins)","category":"page"},{"location":"#Concepts","page":"Home","title":"Concepts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Sequence is a sequence (e.g. contig) clustered by the binner\nA Genome is a target genome that should be reconstructed by the binner. It can be a virus, organism, plasmid etc. Every Genome have several Sources, and one parent Clade.\nA Flag marks the certaincy about a boolean attribute of a genome, like \"is this a virus?\".\nSources are the sequences that Genomes are composed of. These are typically the reference genome sequences originally obtained by assembly of a purified genome (e.g. clonal colony). Sequences map to zero or more Sources at particular spans, i.e. locations.\nA Clade contain one or more Genomes or Clades. Clades containing genomes are rank 1, and clades containing rank N clades are rank N+1 clades. All genomes descend from a chain of exactly N ranks of clades, where N > 0.\nA Bin is a set of Sequences created by the binner. Every bin is benchmarked against all genomes and clades in the reference.\nA Reference is composed of:\nThe genomes, a set of Genomes, each with a set of Sources and Flags\nThe taxmaps, a full set of Clades that encompasses every Genome at N ranks (where N > 0)\nThe sequences, a list of Sequences, each with zero or more mappings to Sources.\nA Binning is a set of Bins benchmarked against a Reference","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Reference in the left sidebar.","category":"page"}]
}
