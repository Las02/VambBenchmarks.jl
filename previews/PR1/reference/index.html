<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · VambBenchmarks.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VambBenchmarks.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.Bin" href="#VambBenchmarks.Bin"><code>VambBenchmarks.Bin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bin(name::AbstractString, sequences, targets)</code></pre><p><code>Bin</code>s each represent a bin created by the binner. Conceptually, they are simply a set of <code>Sequence</code> with a name attached. Practically, every <code>Bin</code> is benchmarked against all <code>Genome</code>s and <code>Clade</code>s of a given <code>Reference</code>, so each <code>Bin</code> stores data about its intersection with every genome/clade, e.g. its purity and recall.</p><p>Like <code>Source</code>s, <code>Bin</code>s also have an <em>assembly size</em> for a given source. This is the number of base pairs in the source covered by any sequence in the <code>Bin</code>, which is always a subset of the <code>Source</code>&#39;s assembly size.</p><p>Benchmark statistics for a <code>Bin</code>/<code>Genome</code> can be done with either <em>assemblies or _genomes</em> as the ground truth.</p><ul><li>True positives (TP) are defined as the sum of assembly sizes over all sources in the genome</li><li>False positives (FP) are the sum of length of sequences in the bin not mapping to the <code>Genome</code></li><li>False negatives (FN) is either the genome assembly size or genome size minus TP.</li></ul><p>For <code>Bin</code>/<code>Clade</code> pairs B/C, recall is the maximal recall of B/Ch for all children Ch of C. Precision is the sum of lengths of sequences mapping to any child of the clade divided by the sum of lengths of all sequences in the bin.</p><p>See also: <a href="#VambBenchmarks.Binning"><code>Binning</code></a>, <a href="#VambBenchmarks.Genome"><code>Genome</code></a>, <a href="#VambBenchmarks.Clade"><code>Clade</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bin = first(binning.bins)
Bin &quot;C1&quot;
  Sequences: 2
  Breadth:   65
  Intersecting 1 genomes

julia&gt; first(bin.sequences)
Sequence(&quot;s1&quot;, 25)

julia&gt; f1(first(ref.genomes), bin)
0.625</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/bin.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.Binning" href="#VambBenchmarks.Binning"><code>VambBenchmarks.Binning</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Binning</code></pre><p>A <code>Binning</code> represents a set of <code>Bin</code>s benchmarked against a <code>Reference</code>. <code>Binning</code>s can be created given a set of <code>Bin</code>s and a <code>Reference</code>, where the bins may potentially be loaded from a <code>.tsv</code> file. The field <code>binning.recoverable_genomes</code> shows the maximal number of recoverable genomes at given recall levels given perfect binning. The fields <code>recovered_asms</code> and <code>recovered_genomes</code> are used for benchmarking, these are normally output using the <code>print_matrix</code> function.</p><p>See also: <a href="#VambBenchmarks.print_matrix-Tuple{Binning}"><code>print_matrix</code></a>, <a href="#VambBenchmarks.Bin"><code>Bin</code></a>, <a href="#VambBenchmarks.Reference"><code>Reference</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bins = gold_standard(ref);

julia&gt; bins isa Binning
true

julia&gt; VambBenchmarks.n_nc(binning)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/binning.jl#L4-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.Clade" href="#VambBenchmarks.Clade"><code>VambBenchmarks.Clade</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Clade{Genome}(name::AbstractString, child::Union{Clade{Genome}, Genome})</code></pre><p>A <code>Clade</code> represents any clade above <code>Genome</code>. Every <code>Genome</code> is expected to belong to the same number of clades, e.g. there may be exactly 7 levels of clades above every <code>Genome</code>. <code>Clade</code>s always have at least one child (which is either a <code>Genome</code> or a <code>Clade</code> one rank lower), and a parent, unless it&#39;s the unique top clade from which all other clades and genomes descend from. The rank of a <code>Genome</code> is 0, clades that contain genomes have rank 1, and clades containing rank-1 clades have rank 2 etc. By default, zero-indexed ranks correspond to OTU, species, genus, family, order, class, phylum and domain.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; top_clade(ref)
Genus &quot;F&quot;, 3 genomes
├─ Species &quot;D&quot;, 2 genomes
│  ├─ Genome(gA)
│  └─ Genome(gB)
└─ Species &quot;E&quot;, 1 genome
   └─ Genome(gC)

julia&gt; top_clade(ref).children
2-element Vector{Clade{Genome}}:
 Species &quot;D&quot;, 2 genomes
 Species &quot;E&quot;, 1 genome</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/clade.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.FlagSet" href="#VambBenchmarks.FlagSet"><code>VambBenchmarks.FlagSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FlagSet &lt;: AbstractSet{Flag}</code></pre><p>Flags are compact sets of <code>Flag</code> associated to a Genome. You can construct them from an iterable of <code>Flag</code>, e.g. a 1-element tuple. <code>FlagSet</code> support most set operations efficiently.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; flags = FlagSet((Flags.organism, Flags.virus));

julia&gt; Flags.virus in flags
true

julia&gt; isdisjoint(flags, FlagSet((Flags.organism,)))
false</code></pre><p>See also: <a href="#VambBenchmarks.Flags.Flag"><code>Flag</code></a>, <a href="#VambBenchmarks.Genome"><code>Genome</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/flags.jl#L21-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.Flags.Flag" href="#VambBenchmarks.Flags.Flag"><code>VambBenchmarks.Flags.Flag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Flag</code></pre><p>A flag is a boolean associated to a <code>Genome</code>, stored in a <code>Flags</code> object. A flag may be e.g. <code>Flag.organism</code>, signaling that the genome is known to be an organism.</p><p>See also: <a href="#VambBenchmarks.FlagSet"><code>FlagSet</code></a>, <a href="#VambBenchmarks.Genome"><code>Genome</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/flags.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.Genome" href="#VambBenchmarks.Genome"><code>VambBenchmarks.Genome</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Genome(name::AbstractString [flags::FlagSet])</code></pre><p><code>Genome</code>s represent individual target genomes (organisms, plasmids, viruses etc), analogous to lowest-level clade that can be reconstructed. Conceptually, <code>Genome</code>s contain one or more <code>Source</code>s, and to a single parent <code>Clade</code>. They are identified uniquely among genomes by their name.</p><p>A genome have a <em>genome size</em>, which is the sum of the length of all its sources. We consider this to be the true size of the biological genome (assuming its full sequence is contained in its sources), as well as an <em>assembly size</em>, which represent the sum of the assembly sizes of each source.</p><p>See also: <a href="#VambBenchmarks.Clade"><code>Clade</code></a>, <a href="#VambBenchmarks.Source"><code>Source</code></a>, <a href="#VambBenchmarks.mrca-Tuple{Union{Clade{Genome}, Genome}, Union{Clade{Genome}, Genome}}"><code>mrca</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gA, gB, gC = collect(ref.genomes);

julia&gt; mrca(gA, gB)
Species &quot;D&quot;, 2 genomes
├─ Genome(gA)
└─ Genome(gB)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/genome.jl#L15-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.Reference" href="#VambBenchmarks.Reference"><code>VambBenchmarks.Reference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Reference</code></pre><p>A <code>Reference</code> contains the ground truth to benchmark against. Conceptually, it consists of the following parts:</p><ul><li>A list of genomes, each with sources</li><li>The full taxonomic tree, as lists of clades</li><li>A list of sequences, each with a list of (source, span) to where it maps.</li></ul><p>Normally, the types <code>FlagSet</code> <code>Genome</code>, <code>Source</code>, <code>Clade</code> and <code>Sequence</code> do not need to be constructed manually, but are constructed when the <code>Reference</code> is loaded from a JSON file.</p><p>Construct a <code>Reference</code> with <code>open(i -&gt; Reference(i), &quot;path/to/ref.json&quot;)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ngenomes(ref)
3

julia&gt; nseqs(ref)
11

julia&gt; first(ref.genomes) isa Genome
true</code></pre><p>See also: <a href="#VambBenchmarks.subset-Tuple{Reference}"><code>subset</code></a>, <a href="#VambBenchmarks.Genome"><code>Genome</code></a>, <a href="#VambBenchmarks.Clade"><code>Clade</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/reference.jl#L10-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.Sequence" href="#VambBenchmarks.Sequence"><code>VambBenchmarks.Sequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sequence(name::AbstractString, length::Integer)</code></pre><p>Type that represents a binnable sequence. Sequences do not contain other information than their name and their length, and are identified by their name.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Sequence(&quot;abc&quot;, 5)
Sequence(&quot;abc&quot;, 5)

julia&gt; Sequence(&quot;abc&quot;, 5) == Sequence(&quot;abc&quot;, 9)
true

julia&gt; Sequence(&quot;abc&quot;, 0)
ERROR: ArgumentError: Cannot instantiate an empty sequence</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/sequence.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.Source" href="#VambBenchmarks.Source"><code>VambBenchmarks.Source</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Source{Genome}(g::Genome, name::AbstractString, length::Integer)</code></pre><p>Sources are the &quot;ground truth&quot; sequences that the binning attempts to recreate. For example, the assembled contigs of the reference genome (typically full, closed circular contigs) as found in NCBI or elsewhere are each <code>Source</code>s. Many <code>Genome</code>s only contain a single <code>Source</code> namely its full assembled genome. Each <code>Source</code> has a single parent <code>Genome</code>, and a unique name which identifies it.</p><p><code>Source</code>s have zero or more mapping <code>Sequence</code>s, that each map to the <code>Source</code> at a given span given by a <code>UnitRange{Int}</code>.</p><p><code>Source</code>s have an <em>assembly size</em>, which is the number of base pairs where any sequence map to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/source.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.mrca-Tuple{Union{Clade{Genome}, Genome}, Union{Clade{Genome}, Genome}}" href="#VambBenchmarks.mrca-Tuple{Union{Clade{Genome}, Genome}, Union{Clade{Genome}, Genome}}"><code>VambBenchmarks.mrca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mrca(a::Node, b::Node)::Node</code></pre><p>Compute the most recent common ancestor (MRCA) of <code>a</code> and <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/genome.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.print_matrix-Tuple{Binning}" href="#VambBenchmarks.print_matrix-Tuple{Binning}"><code>VambBenchmarks.print_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_matrix(::Binning; level=0, assembly=true)</code></pre><p>Print the number of reconstructed assemblies or genomes at the given taxonomic level (rank). Level 0 corresponds to genomes, level 1 to species, etc. If <code>assembly</code>, print the number of reconstructed assemblies, else print the level of reconstructed genomes.</p><p>See also: <a href="#VambBenchmarks.Binning"><code>Binning</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/binning.jl#L81-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.subset!-Tuple{Reference}" href="#VambBenchmarks.subset!-Tuple{Reference}"><code>VambBenchmarks.subset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subset!(ref::Reference, sequences::Function, genomes::Function)::Reference</code></pre><p>Mutate <code>ref</code> in place, removing genomes and sequences. Keep only sequences S where <code>sequences(S)</code> returns <code>true</code> and genomes G for which <code>genomes(G)</code> returns <code>true</code>.</p><p>See also: <a href="#VambBenchmarks.subset-Tuple{Reference}"><code>subset</code></a>, <a href="#VambBenchmarks.Reference"><code>Reference</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ref
Reference
  Genomes:    3
  Sequences:  11
  Ranks:      3
  Seq length: 10
  Assembled:  66.8 %

julia&gt; subset(ref; genomes=g -&gt; Flags.organism in flags(g))
Reference
  Genomes:    2
  Sequences:  11
  Ranks:      3
  Seq length: 10
  Assembled:  91.3 %

julia&gt; VambBenchmarks.subset(ref; sequences=s -&gt; length(s) ≥ 25)
Reference
  Genomes:    3
  Sequences:  9
  Ranks:      3
  Seq length: 25
  Assembled:  61.1 %</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/reference.jl#L90-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VambBenchmarks.subset-Tuple{Reference}" href="#VambBenchmarks.subset-Tuple{Reference}"><code>VambBenchmarks.subset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subset(ref::Reference; kwargs...)</code></pre><p>Non-mutating copying version of <code>subset</code>.</p><p>See also: <a href="#VambBenchmarks.subset!-Tuple{Reference}"><code>subset!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakobnissen/VambBenchmarks.jl/blob/76a3aff07396524d6cf9b8f5fd0886346383624a/src/reference.jl#L168-L174">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 4 April 2023 07:57">Tuesday 4 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
